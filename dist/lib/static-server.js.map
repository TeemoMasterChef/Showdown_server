{
  "version": 3,
  "sources": ["../../lib/static-server.ts"],
  "sourcesContent": ["/**\r\n * Static server\r\n *\r\n * API resembles node-static, but with some differences:\r\n *\r\n * - `serve`'s callback needs to return `true` to suppress the default error page\r\n * - everything is Promises\r\n * - no customizing cache time by filename\r\n * - no index.json directory streaming (it was undocumented; you weren't using it)\r\n *\r\n * Forked from node-static @\r\n * https://github.com/cloudhead/node-static/blob/e49fbd728e93294c225f52103962e56aab86cb1a/lib/node-static.js\r\n *\r\n * @author Guangcong Luo <guangcongluo@gmail.com>, Alexis Sellier, Brett Zamir\r\n * @license MIT\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport fsP from 'node:fs/promises';\r\nimport http from 'node:http';\r\nimport path from 'node:path';\r\n\r\nconst DEBUG = false;\r\nexport const SERVER_INFO = 'node-static-vendored/1.0';\r\n\r\nexport type Headers = Record<string, string>;\r\nexport type Options = {\r\n\t/** Root directory to serve files from. */\r\n\troot?: string,\r\n\t/** Index file when serving a directory. */\r\n\tindexFile?: string,\r\n\t/** Default extension to append to files if not found. */\r\n\tdefaultExtension?: string,\r\n\t/** Cache time in seconds. null = no cache header. undefined = default (3600). 0 = no cache. */\r\n\tcacheTime?: number | null,\r\n\t/** Serve `.gz` files if available. */\r\n\tgzip?: boolean | RegExp,\r\n\t/** Custom headers for success responses (not sent on errors). */\r\n\theaders?: Headers,\r\n\t/** Server header. `null` to disable. */\r\n\tserverInfo?: string | null,\r\n};\r\nexport type Result = {\r\n\tstatus: number,\r\n\theaders: Record<string, string>,\r\n\tmessage: string | undefined,\r\n\t/** Have we already responded? */\r\n\talreadySent: boolean,\r\n};\r\n/** Return true to suppress default error page */\r\nexport type ErrorCallback = (result: Result) => boolean | void;\r\n\r\nexport const mimeTypes: { [key: string]: string } = {\r\n\t'.html': 'text/html;charset=utf-8',\r\n\t'.htm': 'text/html;charset=utf-8',\r\n\t'.css': 'text/css;charset=utf-8',\r\n\t'.js': 'application/javascript;charset=utf-8',\r\n\t'.jsx': 'application/javascript;charset=utf-8',\r\n\t'.cjs': 'application/javascript;charset=utf-8',\r\n\t'.mjs': 'application/javascript;charset=utf-8',\r\n\t'.json': 'application/json;charset=utf-8',\r\n\t'.ts': 'application/typescript;charset=utf-8',\r\n\t'.xml': 'application/xml;charset=utf-8',\r\n\t'.txt': 'text/plain;charset=utf-8',\r\n\t'.md': 'text/markdown;charset=utf-8',\r\n\r\n\t'.png': 'image/png',\r\n\t'.jpg': 'image/jpeg',\r\n\t'.jpeg': 'image/jpeg',\r\n\t'.gif': 'image/gif',\r\n\t'.svg': 'image/svg+xml;charset=utf-8',\r\n\t'.ico': 'image/x-icon',\r\n\t'.bmp': 'image/bmp',\r\n\t'.webp': 'image/webp',\r\n\r\n\t'.woff': 'font/woff',\r\n\t'.woff2': 'font/woff2',\r\n\t'.ttf': 'font/ttf',\r\n\t'.eot': 'application/vnd.ms-fontobject',\r\n\r\n\t'.zip': 'application/zip',\r\n\t'.tar': 'application/x-tar',\r\n\t'.gz': 'application/gzip',\r\n\r\n\t'.mp3': 'audio/mpeg',\r\n\t'.wav': 'audio/wav',\r\n\t'.ogg': 'audio/ogg',\r\n\t'.mp4': 'video/mp4',\r\n\t'.webm': 'video/webm',\r\n};\r\n\r\nexport class StaticServer {\r\n\troot: string;\r\n\toptions: Options;\r\n\tcacheTime: number | null = 3600;\r\n\tdefaultHeaders: Headers = {};\r\n\t/** Contains the `.`, unlike options.defaultExtension */\r\n\tdefaultExtension = '';\r\n\tconstructor(root: string, options?: Options);\r\n\tconstructor(options?: Options);\r\n\tconstructor(root?: Options | string | null, options?: Options) {\r\n\t\tif (root && typeof root === 'object') {\r\n\t\t\toptions = root;\r\n\t\t\troot = null;\r\n\t\t}\r\n\r\n\t\t// resolve() doesn't normalize (to lowercase) drive letters on Windows\r\n\t\tthis.root = path.normalize(path.resolve(root || '.'));\r\n\t\tthis.options = options || {};\r\n\r\n\t\tthis.options.indexFile ||= 'index.html';\r\n\r\n\t\tif (this.options.cacheTime !== undefined) {\r\n\t\t\tthis.cacheTime = this.options.cacheTime;\r\n\t\t}\r\n\r\n\t\tif (this.options.defaultExtension) {\r\n\t\t\tthis.defaultExtension = `.${this.options.defaultExtension}`;\r\n\t\t}\r\n\r\n\t\tif (this.options.serverInfo !== null) {\r\n\t\t\tthis.defaultHeaders['server'] = this.options.serverInfo || SERVER_INFO;\r\n\t\t}\r\n\r\n\t\tfor (const k in this.options.headers) {\r\n\t\t\tthis.defaultHeaders[k] = this.options.headers[k];\r\n\t\t}\r\n\t}\r\n\r\n\tasync serveDir(\r\n\t\tpathname: string, req: http.IncomingMessage, res: http.ServerResponse\r\n\t): Promise<Result> {\r\n\t\tconst htmlIndex = path.join(pathname, this.options.indexFile!);\r\n\r\n\t\ttry {\r\n\t\t\tconst stat = await fsP.stat(htmlIndex);\r\n\t\t\tconst status = 200;\r\n\t\t\tconst headers = {};\r\n\t\t\tconst originalPathname = decodeURIComponent(new URL(req.url!, 'http://localhost').pathname);\r\n\t\t\tif (originalPathname.length && !originalPathname.endsWith('/')) {\r\n\t\t\t\treturn this.getResult(301, { 'Location': originalPathname + '/' });\r\n\t\t\t} else {\r\n\t\t\t\treturn this.respond(status, headers, htmlIndex, stat, req, res);\r\n\t\t\t}\r\n\t\t} catch {\r\n\t\t\treturn this.getResult(404);\r\n\t\t}\r\n\t}\r\n\r\n\tasync serveFile(\r\n\t\tpathname: string, status: number, headers: Headers, req: http.IncomingMessage, res: http.ServerResponse,\r\n\t\terrorCallback?: ErrorCallback\r\n\t): Promise<Result> {\r\n\t\tpathname = this.resolve(pathname);\r\n\r\n\t\tconst stat = await fsP.stat(pathname);\r\n\t\tconst result = await this.respond(status, headers, pathname, stat, req, res);\r\n\t\treturn this.finish(result, req, res, errorCallback);\r\n\t}\r\n\r\n\tgetResult(status: number, headers: Headers = {}, alreadySent = false): Result {\r\n\t\tif (this.defaultHeaders['server']) {\r\n\t\t\theaders['server'] ||= this.defaultHeaders['server'];\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tstatus,\r\n\t\t\theaders,\r\n\t\t\tmessage: http.STATUS_CODES[status],\r\n\t\t\talreadySent,\r\n\t\t};\r\n\t}\r\n\r\n\tfinish(\r\n\t\tresult: Result, req: http.IncomingMessage, res: http.ServerResponse, errorCallback?: ErrorCallback\r\n\t): Result {\r\n\t\t// If `alreadySent`, it's been taken care of in `this.stream`.\r\n\t\tif (!result.alreadySent && !errorCallback?.(result)) {\r\n\t\t\tres.writeHead(result.status, result.headers);\r\n\t\t\tif (result.status >= 400 && req.method !== 'HEAD') {\r\n\t\t\t\tres.write(`${result.status} ${result.message}`);\r\n\t\t\t}\r\n\t\t\tres.end();\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tasync servePath(\r\n\t\tpathname: string, status: number, headers: Headers, req: http.IncomingMessage, res: http.ServerResponse\r\n\t): Promise<Result> {\r\n\t\tpathname = this.resolve(pathname);\r\n\r\n\t\t// Make sure we're not trying to access a\r\n\t\t// file outside of the root.\r\n\t\tif (!pathname.startsWith(this.root)) {\r\n\t\t\t// Forbidden\r\n\t\t\treturn this.getResult(403);\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconst stat = await fsP.stat(pathname);\r\n\t\t\tif (stat.isFile()) { // Stream a single file.\r\n\t\t\t\treturn this.respond(status, headers, pathname, stat, req, res);\r\n\t\t\t} else if (stat.isDirectory()) { // Stream a directory of files.\r\n\t\t\t\treturn this.serveDir(pathname, req, res);\r\n\t\t\t} else {\r\n\t\t\t\treturn this.getResult(400);\r\n\t\t\t}\r\n\t\t} catch {\r\n\t\t\t// possibly not found, check default extension\r\n\t\t\tif (this.defaultExtension) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst stat = await fsP.stat(pathname + this.defaultExtension);\r\n\t\t\t\t\tif (stat.isFile()) {\r\n\t\t\t\t\t\treturn this.respond(status, headers, pathname + this.defaultExtension, stat, req, res);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.getResult(400);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch {\r\n\t\t\t\t\t// really not found\r\n\t\t\t\t\treturn this.getResult(404);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn this.getResult(404);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tresolve(pathname: string) {\r\n\t\treturn path.resolve(path.join(this.root, pathname));\r\n\t}\r\n\r\n\tasync serve(req: http.IncomingMessage, res: http.ServerResponse, errorCallback?: ErrorCallback): Promise<Result> {\r\n\t\tlet pathname;\r\n\t\ttry {\r\n\t\t\tpathname = decodeURIComponent(new URL(req.url!, 'http://localhost').pathname);\r\n\t\t} catch {\r\n\t\t\treturn this.finish(this.getResult(400), req, res, errorCallback);\r\n\t\t}\r\n\r\n\t\tconst result = await this.servePath(pathname, 200, {}, req, res);\r\n\t\treturn this.finish(result, req, res, errorCallback);\r\n\t}\r\n\r\n\t/** Check if we should consider sending a gzip version of the file based on the\r\n\t  * file content type and client's Accept-Encoding header value. */\r\n\tgzipOk(req: http.IncomingMessage, contentType: string) {\r\n\t\tconst enable = this.options.gzip;\r\n\t\tif (enable === true || ((enable instanceof RegExp) && enable.test(contentType))) {\r\n\t\t\treturn req.headers['accept-encoding']?.includes('gzip');\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/** Send a gzipped version of the file if the options and the client indicate gzip is enabled and\r\n\t  * we find a .gz file matching the static resource requested. */\r\n\trespondGzip(\r\n\t\tstatus: number, contentType: string, _headers: Headers, file: string, stat: fs.Stats,\r\n\t\treq: http.IncomingMessage, res: http.ServerResponse\r\n\t): Promise<Result> {\r\n\t\tif (!this.gzipOk(req, contentType)) {\r\n\t\t\t// Client doesn't want gzip\r\n\t\t\treturn this.respondNoGzip(status, contentType, _headers, file, stat, req, res);\r\n\t\t}\r\n\t\tconst gzFile = `${file}.gz`;\r\n\t\treturn fsP.stat(gzFile).catch(() => null).then(gzStat => {\r\n\t\t\tif (gzStat?.isFile()) {\r\n\t\t\t\tconst vary = _headers['Vary'];\r\n\t\t\t\t_headers['Vary'] = (vary && vary !== 'Accept-Encoding' ? `${vary}, ` : '') + 'Accept-Encoding';\r\n\t\t\t\t_headers['Content-Encoding'] = 'gzip';\r\n\t\t\t\tstat.size = gzStat.size;\r\n\t\t\t\tfile = gzFile;\r\n\t\t\t}\r\n\t\t\treturn this.respondNoGzip(status, contentType, _headers, file, stat, req, res);\r\n\t\t});\r\n\t}\r\n\r\n\tparseByteRange(req: http.IncomingMessage, stat: fs.Stats) {\r\n\t\tconst byteRange = {\r\n\t\t\tfrom: 0,\r\n\t\t\tto: 0,\r\n\t\t\tvalid: false,\r\n\t\t};\r\n\r\n\t\tconst rangeHeader = req.headers['range'];\r\n\t\tconst flavor = 'bytes=';\r\n\r\n\t\tif (rangeHeader) {\r\n\t\t\tif (rangeHeader.startsWith(flavor) && !rangeHeader.includes(',')) {\r\n\t\t\t\t/* Parse */\r\n\t\t\t\tconst splitRangeHeader = rangeHeader.substr(flavor.length).split('-');\r\n\t\t\t\tbyteRange.from = parseInt(splitRangeHeader[0]);\r\n\t\t\t\tbyteRange.to = parseInt(splitRangeHeader[1]);\r\n\r\n\t\t\t\t/* Replace empty fields of differential requests by absolute values */\r\n\t\t\t\tif (isNaN(byteRange.from) && !isNaN(byteRange.to)) {\r\n\t\t\t\t\tbyteRange.from = stat.size - byteRange.to;\r\n\t\t\t\t\tbyteRange.to = stat.size ? stat.size - 1 : 0;\r\n\t\t\t\t} else if (!isNaN(byteRange.from) && isNaN(byteRange.to)) {\r\n\t\t\t\t\tbyteRange.to = stat.size ? stat.size - 1 : 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* General byte range validation */\r\n\t\t\t\tif (!isNaN(byteRange.from) && !isNaN(byteRange.to) && 0 <= byteRange.from && byteRange.from <= byteRange.to) {\r\n\t\t\t\t\tbyteRange.valid = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (DEBUG) console.warn('Request contains invalid range header: ', splitRangeHeader);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (DEBUG) console.warn('Request contains unsupported range header: ', rangeHeader);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn byteRange;\r\n\t}\r\n\r\n\tasync respondNoGzip(\r\n\t\tstatus: number, contentType: string, _headers: Headers, file: string, stat: fs.Stats,\r\n\t\treq: http.IncomingMessage, res: http.ServerResponse\r\n\t): Promise<Result> {\r\n\t\tconst mtime = Date.parse(stat.mtime as any);\r\n\t\tconst headers: Headers = {};\r\n\t\tconst clientETag = req.headers['if-none-match'];\r\n\t\tconst clientMTime = Date.parse(req.headers['if-modified-since']!);\r\n\t\tconst byteRange = this.parseByteRange(req, stat);\r\n\t\tlet startByte = 0;\r\n\t\tlet length = stat.size;\r\n\r\n\t\t/* Handle byte ranges */\r\n\t\tif (byteRange.valid) {\r\n\t\t\tif (byteRange.to < length) {\r\n\t\t\t\t// Note: HTTP Range param is inclusive\r\n\t\t\t\tstartByte = byteRange.from;\r\n\t\t\t\tlength = byteRange.to - byteRange.from + 1;\r\n\t\t\t\tstatus = 206;\r\n\r\n\t\t\t\t// Set Content-Range response header (we advertise initial resource size on server here (stat.size))\r\n\t\t\t\theaders['Content-Range'] = `bytes ${byteRange.from}-${byteRange.to}/${stat.size}`;\r\n\t\t\t} else {\r\n\t\t\t\tbyteRange.valid = false;\r\n\t\t\t\tif (DEBUG) {\r\n\t\t\t\t\tconsole.warn('Range request exceeds file boundaries, goes until byte no', byteRange.to, 'against file size of', length, 'bytes');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* In any case, check for unhandled byte range headers */\r\n\t\tif (!byteRange.valid && req.headers['range']) {\r\n\t\t\tif (DEBUG) console.error(new Error('Range request present but invalid, might serve whole file instead'));\r\n\t\t}\r\n\r\n\t\t// Copy default headers\r\n\t\tfor (const k in this.defaultHeaders) headers[k] = this.defaultHeaders[k];\r\n\r\n\t\theaders['Etag'] = JSON.stringify([stat.ino, stat.size, mtime].join('-'));\r\n\t\theaders['Date'] = new Date().toUTCString();\r\n\t\theaders['Last-Modified'] = new Date(stat.mtime).toUTCString();\r\n\t\theaders['Content-Type'] = contentType;\r\n\t\theaders['Content-Length'] = length as any;\r\n\r\n\t\t// Copy custom headers\r\n\t\tfor (const k in _headers) { headers[k] = _headers[k]; }\r\n\r\n\t\t// Conditional GET\r\n\t\t// If the \"If-Modified-Since\" or \"If-None-Match\" headers\r\n\t\t// match the conditions, send a 304 Not Modified.\r\n\t\tif ((clientMTime || clientETag) &&\r\n\t\t\t(!clientETag || clientETag === headers['Etag']) &&\r\n\t\t\t(!clientMTime || clientMTime >= mtime)) {\r\n\t\t\t// 304 response should not contain entity headers\r\n\t\t\tfor (const entityHeader of [\r\n\t\t\t\t'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-Location', 'Content-MD5', 'Content-Range', 'Content-Type', 'Expires', 'Last-Modified',\r\n\t\t\t]) {\r\n\t\t\t\tdelete headers[entityHeader];\r\n\t\t\t}\r\n\t\t\treturn this.getResult(304, headers);\r\n\t\t} else if (req.method === 'HEAD') {\r\n\t\t\treturn this.getResult(status, headers);\r\n\t\t} else {\r\n\t\t\tres.writeHead(status, headers);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tawait this.stream(file, length, startByte, res);\r\n\t\t\t\treturn this.getResult(status, headers, true);\r\n\t\t\t} catch {\r\n\t\t\t\t// too late to actually send the 500 header\r\n\t\t\t\treturn this.getResult(500, {}, true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trespond(\r\n\t\tstatus: number, _headers: Headers, file: string, stat: fs.Stats,\r\n\t\treq: http.IncomingMessage, res: http.ServerResponse\r\n\t): Promise<Result> {\r\n\t\tconst contentType = _headers['Content-Type'] ||\r\n\t\t\tmimeTypes[path.extname(file)] ||\r\n\t\t\t'application/octet-stream';\r\n\t\t_headers = this.setCacheHeaders(_headers);\r\n\r\n\t\tif (this.options.gzip) {\r\n\t\t\treturn this.respondGzip(status, contentType, _headers, file, stat, req, res);\r\n\t\t} else {\r\n\t\t\treturn this.respondNoGzip(status, contentType, _headers, file, stat, req, res);\r\n\t\t}\r\n\t}\r\n\r\n\tstream(file: string, length: number, startByte: number, res: http.ServerResponse): Promise<number> {\r\n\t\treturn new Promise<number>((resolve, reject) => {\r\n\t\t\tlet offset = 0;\r\n\r\n\t\t\t// Stream the file to the client\r\n\t\t\tfs.createReadStream(file, {\r\n\t\t\t\tflags: 'r',\r\n\t\t\t\tmode: 0o666,\r\n\t\t\t\tstart: startByte,\r\n\t\t\t\tend: startByte + (length ? length - 1 : 0),\r\n\t\t\t}).on('data', chunk => {\r\n\t\t\t\t// Bounds check the incoming chunk and offset, as copying\r\n\t\t\t\t// a buffer from an invalid offset will throw an error and crash\r\n\t\t\t\tif (chunk.length && offset < length && offset >= 0) {\r\n\t\t\t\t\toffset += chunk.length;\r\n\t\t\t\t}\r\n\t\t\t}).on('close', () => {\r\n\t\t\t\tres.end();\r\n\t\t\t\tresolve(offset);\r\n\t\t\t}).on('error', err => {\r\n\t\t\t\treject(err);\r\n\t\t\t\tconsole.error(err);\r\n\t\t\t}).pipe(res, { end: false });\r\n\t\t});\r\n\t}\r\n\r\n\tsetCacheHeaders(_headers: Headers): Headers {\r\n\t\tif (typeof this.cacheTime === 'number') {\r\n\t\t\t_headers['cache-control'] = `max-age=${this.cacheTime}`;\r\n\t\t}\r\n\t\treturn _headers;\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["path", "fsP", "http", "fs"]
}
